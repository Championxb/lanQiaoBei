# 96.不同的二叉搜索树
# 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树 有多少种？
# 返回满足题意的二叉搜索树的种数。
# 1 <= n <= 19

# 示例：
#     1           1                   2                  3       3
#       \           \               /   \              /        /
#         3           2           1       3          2         1
#        /              \                           /            \
#       2                 3                        1               2
# 输入：n=3  输出：5

# 思路：
# dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
# dp[3]的值为元素1为头节点的数量＋元素2为头节点的数量＋元素3为头结点的数量
# 元素1为头节点的数量=右子树有两个元素的数量*左子树有零个元素的数量
# 元素2为头结点的数量=右子树有一个元素的数量*左子树有一个元素的数量
# 元素3为头结点的数量=右子树有零个元素的数量*左子树有两个元素的数量
# 有2个元素的搜索树数量就是dp[2]。
# 有1个元素的搜索树数量就是dp[1]。
# 有0个元素的搜索树数量就是dp[0]。

# 所以dp[3] = dp[2]*dp[0] + dp[1]*dp[1] + dp[0]*dp[2]
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * 3
        if n <= 2:
            dp[0], dp[1], dp[2] = 1, 1, 2
            return dp[n]
        else:
            dp = [1, 1, 2] + [0] * (n - 2)
        for i in range(3, n + 1):#计算dp[i]
            for j in range(1, i + 1): #遍历每个以j为头节点的数量
                dp[i] += dp[i - j] * dp[j - 1]
        print(dp)
        return dp[n]


n = 5
s = Solution()
print(s.numTrees(n))
